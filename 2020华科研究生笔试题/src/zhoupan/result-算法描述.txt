设计思路:
      1.设共有m个摄像头，n个场景；
      2.数据存储：使用四个数组A,B,C,D。
                        A数组: 用来存储来自文件中的数据，长度为m，A[i]是个链表(0<=i<m)，链表中存储摄像头i监控到的所有场景信息。
                        B数组: 为摄像头解的集合，长度为m, B[i]=1表示第i个摄像头被放入解集,初始B为所有摄像头的集合；
                        C数组: 存储着能监视场景i的摄像头数量，长度为n；
                        D数组: 不能被继续撤销的摄像头i, 则将D[i]设置为1，可用作加快算法运行速度用，长度为m;
      3.将所有摄像头的集合设置为初始解(一定包含所有场景)，该解此时并非最优解；
      4.随机出两个摄像头，根据规则5选出要撤销的摄像头。循环此步，不断减少解集中摄像头的数量。随机取出的两个摄像头可能
         是同一个摄像头或者其中之一不是有效的，对无效的摄像头实行根据一定概率向左或是向右探测，知道找到有效摄像头
      5.分别对摄像头X和Y做如下计算(以X为例)：遍历链表A[X],得到摄像头A的场景集合{c1,c2,...,cn}，查询数组C,从而得到
         集合E{C[c1],C[c2]...},再从E中找出最小的C[i]，记作min_x。同理，计算出摄像头Y的min_y。比较min_x与min_y的大小
        得到较大数max，此max对应的摄像头即是要被删除的摄像头。当min_x=1时，设置D[X]=1,即摄像头X不能被删除，因为
        删除了X的话，min_x对应的场景C[i]就没有摄像头检测到了，从而就没有解了。
     6.若5中的min_x==min_y时，则比较摄像头覆盖场景的数量，然后删除数量较少的那个摄像头。
     7.超时或者循环空转到达空转因子阈值，就跳出循环，结束程序。

伪代码描述：
B<-{x1,x2,..,xm}      //初始解为全部摄像头集合
A<-generate_from(file.txt)
while termination conditions not met do
       X=random(B);             //集合B中随机来个摄像机
       Y=random(B);              //random()需要经过一定操作选取出有效的摄像机
       if(value(X)<value(Y))     //value求解涉及使用设计思路中5，6步提供的思想
                B=B-{X};
       else
                B=B-{Y};
end while
       
         